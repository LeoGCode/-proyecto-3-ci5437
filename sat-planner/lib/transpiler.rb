require "fileutils"

require_relative "../lib/utils"
require_relative "../lib/constraints"

# Models a scheduling problem as a SAT problem and writes it to a file
# in CNF format.
#
# @param [Integer] n_participants Number of participants
# @param [Integer] n_days Number of days
# @param [Integer] n_hours Number of hours
# @param [String] filename Name of the JSON file
# @return [String] Name of the CNF translation file
def translate_to_cnf(n_participants, n_days, n_hours, filename)
  n_available_hours = n_hours - 1
  n_variables = n_participants ** 2 * n_days * n_available_hours
  map_to_cnf = create_map_to_cnf(n_participants, n_days, n_available_hours)

  clauses = []

  args = [clauses, map_to_cnf, n_participants, n_days, n_available_hours]

  add_constraint_1!(*args)
  add_constraint_2!(*args)
  add_constraint_3!(*args)
  add_constraint_4!(*args)
  add_constraint_5!(*args)

  translation_filename = "tmp/" \
  "#{File.basename(filename, File.extname(filename))}_translation.cnf"

  write_cnf_to_file(
    clauses,
    n_variables,
    translation_filename
  )

  translation_filename
end

def write_cnf_to_file(clauses, n_variables, filename)
  # Create the file if it doesn't exist
  FileUtils.mkdir_p(File.dirname(filename))

  File.open(filename, "w") do |f|
    # Write header
    f.puts "c FILE: #{filename}"
    f.puts "c Generated by sat-planner v1.0.0"
    f.puts "c Chus, Ka (2023)"
    f.puts "c"

    # Write clauses
    f.puts "p cnf #{n_variables} #{clauses.size}"

    until clauses.empty?
      f.puts "#{clauses.pop.join(" ")} 0"
    end
  end
end

# Solves a SAT problem in CNF format using the minisat solver.
#
# @param [String] filename Name of the CNF file
# @param [String] bin_path Path to the SAT Solver binary
# @return [String] Name of the solution file
def solve_cnf(filename, bin_path)
  solution_filename = "tmp/" \
  "#{File.basename(filename, File.extname(filename))}_solution.cnf"

  # Run minisat
  `#{bin_path} #{filename} #{solution_filename}`

  solution_filename
end
